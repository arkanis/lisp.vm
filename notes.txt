This file contains some notes, stray thoughts or design ideas. It isn't
documentation! Stuff written here is probably not implemented at all or not in
this way. Be aware: This is just my brain dump.


# ToDo

- Ideas for some confort functions
	- lvm_print_str(lvm, atom) → malloced string
	- lvm_read_str(lvm, str) → atom
- migrate pairs to arrays (when we have variable length atoms)


# Questions

- Any problems with variable length atoms and the GC?


# Source code structure

- Have one public header file. So the library can be used with just one .h and
  .a file (header and static library).
- Have one internal header file that declares all structures used by every one.
- The rest are .c files that implement the delcared functions. Stuff only needed
  in one .c file is declared in that file only.


# Garbage collection

## GC approach

Probably a basic Baker GC:

- Two half spaces.
- One is used to allocate new atoms.
- When it's full all atoms reachable via the roots are copied to the second
  half space.
- Then the first one can be freed (or it's pages invalidated).
- The two half spaces are swapped so that memmory is allocated from the new one.

Collection is triggerd when lvm_alloc_atom() runs out of space in current half
space.

Roots:

- Chain of eval environments (the envs created for lambda evaluation)
- The argument stack
- Builtin zone of the half space
- Slot for current return value?

What about atoms allocated in builtins but not yet added to an environment?

- Solved via the "builtin zone" of the half space
	- Region at the end of the current half space
	- Atoms in there are assumed to be in use by the currently executed builtins
- lvm_eval_builtin() sets the start of the builtin zone before executing a
  builtin and resets it after the builtin returns.
- During builtin execution new atoms are allocated at the end of the half space
  (normal behaviour, no special case needed).
- If there currently exists a "builtin zone" (a builtin is currently executing)
  the GC moves all atoms in there into the new half space. This way temporary
  atoms allocated in builtins remain alive.
BUT: How to patch the pointers to those?! We can't patch the lvm_atom_p
variables in C code.
  => So the builtin zone has to remain where it is...

What about return values?

Can the return value be in flight between eval and builtins when a collection
happens? If so the GC needs to know it so it can use it as root.


## GC tipps from Gittinger

Only call GC at defined moments. If we run out of memory just set a flag and
allocate more memory. Then collect once we reach a defined point where we know
how the environment is: No buildin has stuff on the C stack or in registers we
can't scan.

- AST interpreter: in the trampoline
- Bytecode interpreter: At the start of each bytecode (first thing in the for loop)
- Machine code: At calls, returns and _backwards_ jumps
	- Forward jumps make progress so we don't need to check them
	- The check on return can be optimized by jumping to the GC instead of the
	  return address. When the GC needs to run we just patch the return address
	  to the GC address and store the real return address somewhere else.

madvise was created for sequential sweep phase of the GC. So use it. :)

Finalization with Baker GC:

- Finilazation table with pointers to objects that need finalization
- After copying live objects look through finalization table:
	- If an object doesn't have a forward bit set we need to finalize it
	- If not we just have to patch the pointer to the forward pointer

3 generations of small spaces

Book: Garbage Collection for Uniprocessors from Baker


## Using an value passing stack like Lua

Source:
	24.2 - The Stack - The C API - Programming in Lua
	https://www.lua.org/pil/24.2.html

Lua uses an explicit stack of atoms. All atoms on the stack are retained by the
GC. C functions have to work on atoms through the stack. Atom allocation pushes
the allocated atom on the stack. C code then uses the allocated atom while it's
on the stack.

This solves the reachability problem of atoms and the GC can patch all atom
pointers. All the pointers are on the stack and the C code can't even take a
pointer and store it in a variable.

However this gives the API a very stack based feel and makes simple things
somewhat strange:

	lvm_pair_atom(lvm, lvm_str_atom(lvm, "hello"), lvm_nil_atom(lvm));

would become

	lvm_push_str_atom(lvm, "hello");
	lvm_nil_atom(lvm);
	lvm_pair_atom(lvm);  // pops the previous two atoms

But all in all this might be the simplest way to handle it. Especially since we
already have the argument stack to pass arguments. Also Lua is a well known
scripting language and this might make it easier for people to work this way.


## GC with array atoms

- Array atom: size_t length; lvm_atom_p atoms;
- Halfspace one big array of atoms
- With pairs all atoms are stored in the half space
- With arrays there are some options:
	a) malloc pointer list, array atom points to malloced list
	b) Array content are the length following atoms in half space
	c) Array content are the length consecutive atoms the atom points to

Ultimate goal: No longer use malloc() for anything.

- Variable length atoms, header followed by variable length data:
	- Strings, errors
	- Array element list
- Fixed size atoms: Num, Lambda, Builtin, Syntax
- Symbols and symbol strings are allocated in a different non collected space.
- Singelton atoms (nil, true, false) are allocated in a fixed non collected space.

This would require variable length atoms.


## Lifetimes of environments

How to handle environment lifetime?

Only the GC knows when an environment is no longer needed. So env_destroy()
should not be a part of the public API? But then the application might want to
keep it alive as an interface between the script and the program state.

Approach:

- Envronments created during evaluation are managed by eval().
	- For normal non-capturing lambdas the env is no longer needed after the
	  lambda evaluation.
	- When a lambda captures something the env is transfered to the GC (and
	  freed when no longer reachable).
	- eval() has a buffer of environments, one env for one level of the scope
	  stack.
	- Envs can be reused and don't need to be allocated and freed all the time.


# Argument stack

Why PUSH and POP on an argument stack? Why not Just pop it automatically when
a builtin call is done? There seems to be no real reason.

Manual push and pop might even cause trouble with the GC. If an argument is
poped and a builtin uses it the GC doesn't see it. When the GC is run while the
builtin executes it might free the popped argument while it is still used.

So instead we just put all arguments on the argument stack and give the builtin
an argc and argv style argument list. When the builtin is done we can drop all
arguments from the stack at once.


# Error handling

What about an error atom to unwind the stack when an error occured? Something
like NaN in floating point. Should contain the error message. Might be useful to
build something like exception handling.

- When an error atom is returned during eval() or while evaling lambda arguments
  the evaluation is aborted and the error atom is returned.
- Needs special handling from everything that evals, including all builtins!
- Extend it to reader and printer as well? Useful to unwind the stack in the
  parser?


# Hash tables

Hash function recommended by Gittinger: fnv1a. Seems to be a simple hash
function made for identifiers. Maybe more compact than Murmur3 but probably not
as universal.

Calculate next prime for hash table size:

- Calculate highest set bit of hash table length (count leading zeros instruction)
- Create a fixed table that maps the number of the highest set bit to a fixed
  prime number. This table just has 64 entries filled with pre calculated prime
  numbers.

Not sure if a prime number size really avoids collisions. Would need measuring
with some actual running code (environment accesses).


# User defined atoms

- Use lower 8 bits of lvm_atom_type_t for normal types.
- When type set to LVM_T_USER the higher 24 or 16 bit are the index of the user
  defined atom class (the classes are stored in an interpreter global table).
- A class defines function pointers for interactions with buildin functions
  (e.g. when this atom is evaled, ... are there that many?)
- To create a user defined atom the user first has to register a class. That
  returns a class id with which the user can create user atoms.
- The user defined atom itself just contains a void pointer to whatever the user
  wants to store for that atom.
- Similar to resource objects in PHP? E.g. for stream I/O?


# Structure ideas for a bytecode compiler and interpreter API

lvm_new(...)
	Probably with an options struct with stack size, heap size, etc.
lvm_destroy()
lvm_run(module)

lvm_compile(source_code, existing_module) → module
	Generated code and data is appended to existing_module. If it's NULL a new
	module is created.

lvm_mod_load(filename) → module
lvm_mod_save(module, filename)
lvm_mod_destroy(module)


# Customizable syntax

Pass reader and printer functions in lvm_new() options struct. Then the user can
supply a different parser and printer.


## Lisp style syntax

3141 → LVM_T_NUM
"foo bar" → LVM_T_STR
name → LVM_T_SYM
nil → LVM_T_NIL
true → LVM_T_TRUE
false → LVM_T_FALSE
(a b c) → LVM_T_ARRAY

(set foo 124)
(if cond true_case false_case)
(lambda (args) body...)
(quote expr)

(at array index)

(+ a b)
(- a b)
(* a b)
(/ a b)
(= a b)

(print expr)


## C style syntax

3141 → LVM_T_NUM
"foo bar" → LVM_T_STR
name → LVM_T_SYM
nil → LVM_T_NIL
true → LVM_T_TRUE
false → LVM_T_FALSE
a(b, c) → (a b c) → LVM_T_ARRAY

( expr ) → expr
{ expr expr ... } → (begin expr expr ...)
if expr expr else expr → (if cond true_case false_case)
func(args) { body ... } → (lambda (args) body...)

[a, b, c] → (quote (a b c))
:name → (quote name)

array[index]
a + b    a op b    op is = + - * / ==
	a + b → (+ a b)
	foo = 123 → (set foo 124)

print(expr)


### C style syntax grammar

Tokens:

Keywords and single char tokens:
	func
	if
	else
	( )
	[ ]
	{ }
	,
	:
	+ - * /
	=
	== < >

Values:
	3141 → num
	"foo bar" → str
	name → sym
	nil
	true
	false

Grammar rules:

sep  = ";" | "\n"
expr = num | str | sym | nil | true | false
       "(" expr ")"
       "{" expr [ sep expr ] "}"
       "func" "(" ")" expr
       "func" "(" sym [ "," sym ] ")" expr
       "func" sym "(" ")" expr
       "func" sym "(" sym [ "," sym ] ")" expr
       "if" "(" expr ")" expr
       "if" "(" expr ")" expr "else" expr
       expr "+" expr
       expr "-" expr
       expr "*" expr
       expr "/" expr
       expr "=" expr
       expr "==" expr
       expr "<" expr
       expr ">" expr
       expr "[" expr "]"
       expr "(" ")"
       expr "(" expr [ "," expr ] ")"